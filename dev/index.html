<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ASSET Documentation · ASSET documentation</title><meta name="title" content="ASSET Documentation · ASSET documentation"/><meta property="og:title" content="ASSET Documentation · ASSET documentation"/><meta property="twitter:title" content="ASSET Documentation · ASSET documentation"/><meta name="description" content="Documentation for ASSET documentation."/><meta property="og:description" content="Documentation for ASSET documentation."/><meta property="twitter:description" content="Documentation for ASSET documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ASSET documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ASSET Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Theoretical-Background"><span>Theoretical Background</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ASSET Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ASSET Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SlitSpectroscopyBuddies/ASSET" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ASSET-Documentation"><a class="docs-heading-anchor" href="#ASSET-Documentation">ASSET Documentation</a><a id="ASSET-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#ASSET-Documentation" title="Permalink"></a></h1><ul></ul><article><details class="docstring" open="true"><summary id="ASSET.AbstractBkg"><a class="docstring-binding" href="#ASSET.AbstractBkg"><code>ASSET.AbstractBkg</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractBkg</code></pre><p>Type that defines a background structure, that is used to specify a certain model of the background present in the data and its associated regularization. This structure is used when one want to both estimate the background sources of the data and extracting the spectrum of the object of interest.</p><p>To define a structure <code>B</code> of type <code>AbstractBkg</code>, the user needs to overload three methods:</p><pre><code class="language-julia hljs">julia&gt; get_bkg(B)</code></pre><p>which yields the background as an <code>AbstractArray</code> from parameters contained in <code>B</code>.</p><pre><code class="language-julia hljs">julia&gt; regul(B)</code></pre><p>which yields the result of the regularization term(s), applied to the curent background model, that are used in the a posteriori likelihood minimization.</p><pre><code class="language-julia hljs">julia&gt; fit_bkg!(B, D)</code></pre><p>where <code>D</code> is a <code>CalibratedData</code>. This last function is the one called by <code>extract_spectrum</code> to estimate the background when assuming the object spectrum known (alternate estimation). </p><p><strong>See also</strong></p><ul><li><a href="#ASSET.BkgMdl"><code>BkgMdl</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/372cd9bae63d0d4ca5c5dc43f9ff82e322190471/src/types.jl#L56-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.BkgMdl"><a class="docstring-binding" href="#ASSET.BkgMdl"><code>ASSET.BkgMdl</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BkgMdl(b, R)</code></pre><p>yields a structure of type <code>AbstractBkg</code>, composed of an <code>AbstractArray</code> <code>b</code> and an associated regularization <code>R</code> of type <code>Regularization</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># create a BkgMdl structure
julia&gt; B = BkgMdl(b, R)
# add the structure to an AbstractArray
julia&gt; A = ones(size(b))
julia&gt; A + B</code></pre><p>To apply the regularization to the background array:</p><pre><code class="language-julia hljs">julia&gt; regul(B)</code></pre><p>To fit the background to some <code>CalibratedData</code> <code>D</code>:</p><pre><code class="language-julia hljs">julia&gt; fit_bkg!(B, D, true, kwds...)</code></pre><p>where <code>kwds</code> specifies all the keywords used by the optimization method to estimate the background.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.AbstractBkg"><code>AbstractBkg</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/372cd9bae63d0d4ca5c5dc43f9ff82e322190471/src/bkg_models.jl#L12-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.extract_spectrum!"><a class="docstring-binding" href="#ASSET.extract_spectrum!"><code>ASSET.extract_spectrum!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_spectrum!(z, F, psf, D, Reg [, Bkg]; kwds...)</code></pre><p>estimates the spectrum of an object observed with long-slit spectroscopy, when the data can be corrupted by a background component and noise. The direct model of such data can be writen: <code>d = Bkg + Diag(H)*F*z + n</code> where <code>*</code> the matrix product. <code>z</code> is the spectrum of the object of interest and <code>F</code> its associated interpolation operator, <code>H</code> the operator modeling the Point Spread Function (PSF) of the instrument, while <code>Bkg</code> is the background component to disentangle from the object of interest and <code>n</code> accounts for noises.</p><p>The data and there associated weights are given by the <code>CalibratedData</code> structure <code>D</code>, while the array <code>H</code> is produced using the method <code>psf_map</code> with the arguments <code>psf</code> and <code>psf_center</code>.</p><p>The estimation of the different unknowns relies on the minimization of the a posteriori likelihood, where <code>Reg</code> is the regularization function of <code>z</code> (of type <code>InverseProblem.Regularization</code>) and where <code>Bkg</code> is a structure of type <code>AbstractBkg</code>, which contains a way to produce the background component and its regularization function. If <code>Bkg</code> is not given, the algorithm will suppose that there is no background in the data and will only call <code>fit_spectrum_and_psf!</code>. If there is a <code>Bkg</code> given, the algorithm will alternate the estimation of the background using <code>fit_bkg!</code> with the extraction of the spectrum (done in <code>fit_spectrum_and_psf!</code>).</p><p>Finally, an auto-calibration step can be activated which will refine the parameters and center of the PSF.</p><p><strong>Keywords</strong></p><ul><li><code>auto_calib</code> : (<code>Val(true)</code> by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum. It can also take the value <code>Val(:delay)</code> which will run the algorithm without auto<em>calib until it converges, before activating the `auto</em>calib` and re-running the algorithm.</li><li><code>mask_width</code> : (<code>3</code> by default) defines the number of fwhm of the psf will be used to hide the object on the first iteration of the background estimtion (if thee is one).</li><li><code>max_iter</code> : (<code>1000</code> by default) defines the maximum number of iterations that can do the method (useful when <code>auto_calib=true</code>).</li><li><code>loss_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.</li><li><code>z_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate <code>z</code> as a stop criterion.</li><li><code>extract_kwds</code> : (<code>(verb=true,)</code> by default) where other keywords can be given which are forwarded to the <code>object_step</code> method. </li></ul><p><strong>See also</strong></p><ul><li><a href="#ASSET.AbstractBkg"><code>AbstractBkg</code></a></li><li>[<code>PointSpreadFunctions.AbstractPSF</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/372cd9bae63d0d4ca5c5dc43f9ff82e322190471/src/algorithms.jl#L9-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.ChromaticSeriesExpansionsInterpolator"><a class="docstring-binding" href="#ASSET.ChromaticSeriesExpansionsInterpolator"><code>ASSET.ChromaticSeriesExpansionsInterpolator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ChromaticSeriesExpansionsInterpolator &lt;: LinearMapping</code></pre><p>A structure representing a chromatic series expansions interpolator, which performs linear mapping operations for chromatic data interpolation. </p><p><strong>Arguments</strong></p><ul><li><code>cols</code>: Tuple specifying the number of columns (output dimensions). </li><li><code>rows</code>: Tuple specifying the number of rows (input dimensions).</li><li><code>ker</code>: Kernel object used for interpolation.</li><li><code>X</code>: Array of input positions.</li><li><code>Λ</code>: Array of wavelength or chromatic values.</li><li><code>x</code>: Range of positions for interpolation.</li><li><code>λref</code>: Reference wavelength for normalization.</li><li><code>a</code>: Parameter for scaling or regularization.</li></ul><hr/><pre><code class="language-julia hljs">ChromaticSeriesExpansionsInterpolator{T}(ker::Kernel, X::AbstractArray{T,N}, Λ::AbstractArray{T,N}, x::AbstractRange; order=1, λref=maximum(Λ), a=0.)</code></pre><p>Constructs a <code>ChromaticSeriesExpansionsInterpolator</code> with specified kernel, input arrays, and interpolation range. Optionally specify the interpolation order, reference wavelength, and scaling parameter. </p><p><strong>Arguments</strong></p><ul><li><code>ker</code>: Interpolation kernel.</li><li><code>X</code>: Input position array.</li><li><code>Λ</code>: Input wavelength/chromatic array.</li><li><code>x</code>: Range of positions for interpolation.</li><li><code>order</code>: Interpolation order (default: 1).</li><li><code>λref</code>: Reference wavelength (default: maximum of <code>Λ</code>).</li><li><code>a</code>: Scaling parameter (default: 0).</li></ul><hr/><pre><code class="language-julia hljs">ChromaticSeriesExpansionsInterpolator(ker::Kernel, X::AbstractArray{&lt;:Any,N}, Λ::AbstractArray{&lt;:Any,N}, x::AbstractRange; order=1, λref=maximum(Λ), a=0.)</code></pre><p>Constructs a <code>ChromaticSeriesExpansionsInterpolator</code> with type promotion to <code>Float64</code> for the input arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/372cd9bae63d0d4ca5c5dc43f9ff82e322190471/src/types.jl#L133-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.CalibratedData"><a class="docstring-binding" href="#ASSET.CalibratedData"><code>ASSET.CalibratedData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CalibratedData{T&lt;:AbstractFloat, N, D&lt;:AbstractArray{T,N}}</code></pre><p>A container for storing calibrated scientific data and associated weights  <code>w</code>, the angular separation <code>ρ_map</code> and wavelength <code>λ_map</code> maps calibrating the detector.</p><p><strong>Arguments</strong></p><ul><li><code>d::D</code>: The main scientific data array.</li><li><code>w::D</code>: The weight array corresponding to the data.</li><li><code>ρ_map::D</code>: The spatial map associated with the data.</li><li><code>λ_map::D</code>: The spectral map associated with the data.</li></ul><p>The <code>Base</code> methods <code>axes</code>, <code>size</code>, <code>eltype</code> and <code>show</code> have been overload to be used with such a structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/372cd9bae63d0d4ca5c5dc43f9ff82e322190471/src/types.jl#L9-L24">source</a></section></details></article><ul><li>link to <a href="#ASSET.AbstractBkg"><code>ASSET.AbstractBkg</code></a></li><li>link to <a href="#ASSET.BkgMdl"><code>ASSET.BkgMdl</code></a></li></ul><ul><li><a href="#ASSET.AbstractBkg"><code>ASSET.AbstractBkg</code></a></li><li><a href="#ASSET.BkgMdl"><code>ASSET.BkgMdl</code></a></li><li><a href="#ASSET.CalibratedData"><code>ASSET.CalibratedData</code></a></li><li><a href="#ASSET.ChromaticSeriesExpansionsInterpolator"><code>ASSET.ChromaticSeriesExpansionsInterpolator</code></a></li><li><a href="#ASSET.extract_spectrum!"><code>ASSET.extract_spectrum!</code></a></li></ul><h1 id="Theoretical-Background"><a class="docs-heading-anchor" href="#Theoretical-Background">Theoretical Background</a><a id="Theoretical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Background" title="Permalink"></a></h1><p>The method used in the <a href="https://github.com/SlitSpectroscopyBuddies/ASSET"><code>ASSET</code></a> package requires the following maps as inputs: </p><ul><li>data maps <span>$(d_\ell)_{\ell \in {1:L}}$</span>, where <span>$L$</span> is the amount of dithers/acquisitions/frames;</li><li>weights maps <span>$w_\ell$</span>, where each element can be computed as the inverse variance of the pixel, forming the matrix <span>$W_{\ell}= \Sigma_{\ell}^{-2}$</span>. We assume that a defective pixel or artifacts have an infinite variance, i.e. a zero entry in <span>$W_{\ell}$</span>;</li><li>spatial coordinate maps <span>$X_\ell$</span> where <span>$0$</span> should correspond to the center of the studied object;</li><li>spectral coordinate maps <span>$\Lambda_\ell$</span>.</li></ul><p>The method outputs are the extracted spectrum <span>$z$</span>, sampled over a given regular wavelength grid <span>$(\lambda_n)_{n \in 1:N}$</span>, and the parameters <span>$\theta$</span> of the fitted PSF model. They are obtained by solving:  </p><p>( z,\theta \in \mathrm{arg min} \Big{\sum<em>\ell\Vert d</em>\ell - (m<em>\ell(z,\theta) + b)\Vert</em>{W<em>{\ell}}^2 + \mu</em>z\mathcal{R}<em>z(z) + \mu</em>\theta\mathcal{R}<em>\theta(\theta) + \mu</em>b\mathcal{R}<em>b(b), \Big} ) where \mathcal{R}</em>z<span>$, $\mathcal{R}_\theta$</span> and <span>$\mathcal{R}_b$</span> are respectively the regularization of the extracted spectra, of the PSF parameters if required and of the background, with hyperparameters <span>$\mu_z$</span>, <span>$\mu_\theta$</span> and <span>$\mu_b$</span>. The spatial distribution maps <span>$X$</span> and the background map <span>$b$</span> are auto-calibrated in the process.  The model of the data</p><p>( m<em>\ell(z,\theta) = \alpha</em>\ell Z(\Lambda<em>\ell,z) \odot H(\theta, X</em>\ell, \Lambda_\ell))</p><p>is the Hadamard (element-wise) product of the spectrum interpolated in the camera plane</p><p>( Z(\Lambda,z)<em>{j,k}=\sum</em>n\phi\Big(\frac{\Lambda<em>{j,k}-\lambda</em>n}{\delta<em>\lambda}\Big)z</em>n )</p><p>with <span>$\phi$</span> an interpolation kernel, and of the chromatic PSF <span>$H$</span> (parametric or non-parametric). The package provide several <code>ParametricPSF</code> and <code>NonParametricPSF</code> and the users can easily implement their own. A <code>ParametricPSF</code>  <span>$H$</span> is a function parametrized by a few unknown variables <span>$\theta_m$</span>, thus with low degrees of freedom, <em>e.g.</em> a Gaussian chromatic with a minimum width model: ( H(\theta, X<em>\ell, \Lambda</em>\ell)<em>{j,k} = \big(2 \pi(\theta</em>1 \Lambda<em>{j,k\ell}^2 + \theta</em>2)\big)^{-1}\exp\Big(-\frac{X<em>{j,k,\ell}^2}{2(\theta</em>1\Lambda<em>{j,k,\ell}^2+\theta</em>2)}\Big). )</p><p>It does not require any regularization. See @The:2023 and @Denneulin:2023 for more details. </p><p>A <code>NonParametricPSF</code> is parametrized directly by some profile <span>$(\theta_m)_{m \in  1:M}$</span>, thus with high degrees of freedom , <em>e.g.</em> taking <span>$o$</span> order of the speckles expansion model [@Devaney:2017] which is the interpolation of the profiles <span>$\theta_o$</span> in a reference plane of the spatial coordinates <span>$(x_m)_{m \in 1:M}$</span>,:</p><p>( H(\theta, X<em>\ell, \Lambda</em>\ell)<em>{j,k} = \sum</em>o \gamma(\Lambda<em>\ell)^o \sum</em>m \phi\Big(\frac{\gamma(\Lambda<em>\ell)X</em>\ell - x<em>m}{\delta x}\Big)\theta</em>{m,o}(x_m). )</p><p>For such a PSF, <span>$\theta$</span> must be regularized. The hyperparameter is auto-calibrated in the method (see @The:2023 for and references therein for more details). </p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 14:38">Friday 27 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
