<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ASSET Documentation · ASSET documentation</title><meta name="title" content="ASSET Documentation · ASSET documentation"/><meta property="og:title" content="ASSET Documentation · ASSET documentation"/><meta property="twitter:title" content="ASSET Documentation · ASSET documentation"/><meta name="description" content="Documentation for ASSET documentation."/><meta property="og:description" content="Documentation for ASSET documentation."/><meta property="twitter:description" content="Documentation for ASSET documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ASSET documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ASSET Documentation</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#PSF-models"><span>PSF models</span></a></li><li><a class="tocitem" href="#Fitting-methods"><span>Fitting methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Theoretical-Background"><span>Theoretical Background</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ASSET Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ASSET Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SlitSpectroscopyBuddies/ASSET" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ASSET-Documentation"><a class="docs-heading-anchor" href="#ASSET-Documentation">ASSET Documentation</a><a id="ASSET-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#ASSET-Documentation" title="Permalink"></a></h1><ul><li><a href="#ASSET-Documentation">ASSET Documentation</a></li><li class="no-marker"><ul><li><a href="#Types">Types</a></li><li><a href="#PSF-models">PSF models</a></li><li><a href="#Fitting-methods">Fitting methods</a></li></ul></li><li><a href="#Theoretical-Background">Theoretical Background</a></li></ul><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ASSET.AbstractBkg"><a class="docstring-binding" href="#ASSET.AbstractBkg"><code>ASSET.AbstractBkg</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractBkg</code></pre><p>Type that defines a background structure, that is used to specify a certain model of the background present in the data and its associated regularization. This structure is used when one want to both estimate the background sources of the data and extracting the spectrum of the object of interest.</p><p>To define a structure <code>B</code> of type <code>AbstractBkg</code>, the user needs to overload three methods:</p><pre><code class="language-julia hljs">julia&gt; get_bkg(B)</code></pre><p>which yields the background as an <code>AbstractArray</code> from parameters contained in <code>B</code>.</p><pre><code class="language-julia hljs">julia&gt; regul(B)</code></pre><p>which yields the result of the regularization term(s), applied to the curent background model, that are used in the a posteriori likelihood minimization.</p><pre><code class="language-julia hljs">julia&gt; fit_bkg!(B, D)</code></pre><p>where <code>D</code> is a <code>CalibratedData</code>. This last function is the one called by <code>extract_spectrum</code> to estimate the background when assuming the object spectrum known (alternate estimation). </p><p><strong>See also</strong></p><ul><li><a href="#ASSET.BkgMdl"><code>BkgMdl</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/types.jl#L56-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.ParametricPSF"><a class="docstring-binding" href="#ASSET.ParametricPSF"><code>ASSET.ParametricPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParametricPSF{N} &lt;: AbstractPSF{N}</code></pre><p>An abstract type representing a parametric point spread function (PSF) with <code>N</code> arguments. Subtypes <code>P</code> should implement specific parametric models for PSFs as well as <code>parameters(::P)</code> yielding its parameters, <code>getfwhm(::P)</code> its fwhm and <code>::P(::Int, ::Int)</code> its value at a given position on the detector. Inherits from <code>AbstractPSF{N}</code>.</p><p><strong>See Also</strong></p><ul><li>[<code>AbstractPSF</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/types.jl#L97-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.NonParametricPSF"><a class="docstring-binding" href="#ASSET.NonParametricPSF"><code>ASSET.NonParametricPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonParametricPSF{N} &lt;: AbstractPSF{N}</code></pre><p>An abstract type representing a non-parametric point spread function (PSF) with <code>N</code> arguments. Subtypes of <code>NonParametricPSF</code> are expected to define PSFs that are not described by a fixed set of parameters, but rather by data-driven or empirical representations. Subtypes <code>P</code> should implement specific parametric models for PSFs as well as <code>parameters(::P)</code> yielding its parameters, <code>getfwhm(::P)</code> its fwhm and <code>::P(::Int, ::Int)</code> its value at a given position on the detector.This type is a subtype of <code>AbstractPSF{N}</code>.</p><p><strong>See Also</strong></p><ul><li>[<code>AbstractPSF</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/types.jl#L114-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.BkgMdl"><a class="docstring-binding" href="#ASSET.BkgMdl"><code>ASSET.BkgMdl</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BkgMdl(b, R)</code></pre><p>yields a structure of type <code>AbstractBkg</code>, composed of an <code>AbstractArray</code> <code>b</code> and an associated regularization <code>R</code> of type <code>Regularization</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># create a BkgMdl structure
julia&gt; B = BkgMdl(b, R)
# add the structure to an AbstractArray
julia&gt; A = ones(size(b))
julia&gt; A + B</code></pre><p>To apply the regularization to the background array:</p><pre><code class="language-julia hljs">julia&gt; regul(B)</code></pre><p>To fit the background to some <code>CalibratedData</code> <code>D</code>:</p><pre><code class="language-julia hljs">julia&gt; fit_bkg!(B, D, true, kwds...)</code></pre><p>where <code>kwds</code> specifies all the keywords used by the optimization method to estimate the background.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.AbstractBkg"><code>AbstractBkg</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/bkg_models.jl#L12-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.CalibratedData"><a class="docstring-binding" href="#ASSET.CalibratedData"><code>ASSET.CalibratedData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CalibratedData{T&lt;:AbstractFloat, N, D&lt;:AbstractArray{T,N}}</code></pre><p>A container for storing calibrated scientific data and associated weights  <code>w</code>, the angular separation <code>ρ_map</code> and wavelength <code>λ_map</code> maps calibrating the detector.</p><p><strong>Arguments</strong></p><ul><li><code>d::D</code>: The main scientific data array.</li><li><code>w::D</code>: The weight array corresponding to the data.</li><li><code>ρ_map::D</code>: The spatial map associated with the data.</li><li><code>λ_map::D</code>: The spectral map associated with the data.</li></ul><p>The <code>Base</code> methods <code>axes</code>, <code>size</code>, <code>eltype</code> and <code>show</code> have been overload to be used with such a structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/types.jl#L9-L24">source</a></section></details></article><h2 id="PSF-models"><a class="docs-heading-anchor" href="#PSF-models">PSF models</a><a id="PSF-models-1"></a><a class="docs-heading-anchor-permalink" href="#PSF-models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ASSET.chromGaussianPSF"><a class="docstring-binding" href="#ASSET.chromGaussianPSF"><code>ASSET.chromGaussianPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">chromGaussianPSF(a) -&gt; h</code></pre><p>Yields an AbstractPSF <code>h</code>, more precisely a gaussian chromatic  PSF parametrized by <code>a</code>, such that the gaussian variance is  σ² = aλ².</p><p>Then: </p><pre><code class="language-julia hljs">h(ρ,λ)</code></pre><p>gives the value of the gaussian chromatic PSF for:</p><ul><li><code>ρ</code>, a float giving the position in the slit (in pixels)</li><li><code>λ</code>, a float giving the wavelength (in μm)</li></ul><p>which is:</p><pre><code class="language-julia hljs">    exp(-1/2 ρ²/σ²)/sqrt(2πσ²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/psf_models.jl#L16-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.chromwmwGaussianPSF"><a class="docstring-binding" href="#ASSET.chromwmwGaussianPSF"><code>ASSET.chromwmwGaussianPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">chromwmwGaussianPSF(p) -&gt; h</code></pre><p>Yields an AbstractPSF <code>h</code>, more precisely a gaussian chromatic  PSF parametrized by two variables given in a vector <code>p = [a,b]</code>:</p><ul><li><code>a</code> the chromatic scalling</li><li><code>b</code> the minimum width</li></ul><p>such that the the variance of the PSF is  σ² = aλ² + b</p><p>Then: </p><pre><code class="language-julia hljs">h(ρ,λ)</code></pre><p>gives the value of the gaussian chromatic PSF for:</p><ul><li><code>ρ</code>, a float giving the position in the slit (in pixels)</li><li><code>λ</code>, a float giving the wavelength (in μm)</li></ul><p>which is:</p><pre><code class="language-julia hljs">    exp(-1/2 ρ²/σ²)/sqrt(2πσ²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/psf_models.jl#L61-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.chromMoffatPSF"><a class="docstring-binding" href="#ASSET.chromMoffatPSF"><code>ASSET.chromMoffatPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">chromMoffatPSF(p) -&gt; h</code></pre><p>Yields an AbstractPSF <code>h</code>, more precisely a centrosymetric Moffat chromatic  PSF parametrized by two variables given in a vector <code>p=[a, β]</code>:</p><ul><li>`a the chromatic scalling</li><li><code>β</code> the Moffat parameter</li></ul><p>such that the the variance of the PSF is  σ² = aλ²</p><p>Then: </p><pre><code class="language-julia hljs">h(ρ,λ)</code></pre><p>gives the value of the centrosymetric Moffat chromatic PSF for:</p><ul><li><code>ρ</code>, a float giving the position in the slit (in pixels)</li><li><code>λ</code>, a float giving the wavelength (in μm)</li></ul><p>which is:</p><pre><code class="language-julia hljs">    (1 + ρ²/σ²)^(-β)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/psf_models.jl#L111-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.chromwmwMoffatPSF"><a class="docstring-binding" href="#ASSET.chromwmwMoffatPSF"><code>ASSET.chromwmwMoffatPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">chromwmwMoffatPSF(p) -&gt; h</code></pre><p>Yields an AbstractPSF <code>h</code>, more precisely a centrosymetric Moffat chromatic  PSF parametrized by two variables given in a vector <code>p=[a, b, β]</code>:</p><ul><li><code>a</code> the chromatic scalling</li><li><code>b</code> the minimum width</li><li><code>β</code> the Moffat parameter</li></ul><p>such that the the variance of the PSF is  σ² = aλ² + b</p><p>Then: </p><pre><code class="language-julia hljs">h(ρ,λ)</code></pre><p>gives the value of the centrosymetric Moffat chromatic PSF for:</p><ul><li><code>ρ</code>, a float giving the position in the slit (in pixels)</li><li><code>λ</code>, a float giving the wavelength (in μm)</li></ul><p>which is:</p><pre><code class="language-julia hljs">    (1 + ρ²/σ²)^(-β)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/psf_models.jl#L163-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.SeriesExpansionPSF"><a class="docstring-binding" href="#ASSET.SeriesExpansionPSF"><code>ASSET.SeriesExpansionPSF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SeriesExpansionPSF(x) -&gt; h</code></pre><p>Yields an AbstractPSF <code>h</code>, more precisely a non-parametric PSF using a series expansion approach, parametrized by:</p><ul><li><code>h</code>: a matrix containing the series expansion coefficients</li><li><code>x</code>: a range containing the wavelengths at which the series expansion coefficients are defined</li><li><code>a</code>: a float giving the chromatic scaling (default is 0, i.e., no scaling)</li><li><code>ker</code>: an interpolation kernel (default is CatmullRomSpline with Flat boundary conditions)</li><li><code>R</code>: a regularization (default is Tikhonov regularization)</li></ul><p>Then: </p><pre><code class="language-julia hljs">h(ρ,λ)</code></pre><p>gives the value of the chromatic series expansion PSF for:</p><ul><li><code>ρ</code>, a float giving the position in the slit (in pixels)</li><li><code>λ</code>, a float giving the wavelength (in μm)</li></ul><p>which is given by the <code>ChromaticSeriesExpansionsInterpolator</code> structure.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.ChromaticSeriesExpansionsInterpolator"><code>ChromaticSeriesExpansionsInterpolator</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/psf_models.jl#L221-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.ChromaticSeriesExpansionsInterpolator"><a class="docstring-binding" href="#ASSET.ChromaticSeriesExpansionsInterpolator"><code>ASSET.ChromaticSeriesExpansionsInterpolator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ChromaticSeriesExpansionsInterpolator &lt;: LinearMapping</code></pre><p>A structure representing a chromatic series expansions interpolator, which performs linear mapping operations for chromatic data interpolation. </p><p><strong>Arguments</strong></p><ul><li><code>cols</code>: Tuple specifying the number of columns (output dimensions). </li><li><code>rows</code>: Tuple specifying the number of rows (input dimensions).</li><li><code>ker</code>: Kernel object used for interpolation.</li><li><code>X</code>: Array of input positions.</li><li><code>Λ</code>: Array of wavelength or chromatic values.</li><li><code>x</code>: Range of positions for interpolation.</li><li><code>λref</code>: Reference wavelength for normalization.</li><li><code>a</code>: Parameter for scaling or regularization.</li></ul><hr/><pre><code class="language-julia hljs">ChromaticSeriesExpansionsInterpolator{T}(ker::Kernel, X::AbstractArray{T,N}, Λ::AbstractArray{T,N}, x::AbstractRange; order=1, λref=maximum(Λ), a=0.)</code></pre><p>Constructs a <code>ChromaticSeriesExpansionsInterpolator</code> with specified kernel, input arrays, and interpolation range. Optionally specify the interpolation order, reference wavelength, and scaling parameter. </p><p><strong>Arguments</strong></p><ul><li><code>ker</code>: Interpolation kernel.</li><li><code>X</code>: Input position array.</li><li><code>Λ</code>: Input wavelength/chromatic array.</li><li><code>x</code>: Range of positions for interpolation.</li><li><code>order</code>: Interpolation order (default: 1).</li><li><code>λref</code>: Reference wavelength (default: maximum of <code>Λ</code>).</li><li><code>a</code>: Scaling parameter (default: 0).</li></ul><hr/><pre><code class="language-julia hljs">ChromaticSeriesExpansionsInterpolator(ker::Kernel, X::AbstractArray{&lt;:Any,N}, Λ::AbstractArray{&lt;:Any,N}, x::AbstractRange; order=1, λref=maximum(Λ), a=0.)</code></pre><p>Constructs a <code>ChromaticSeriesExpansionsInterpolator</code> with type promotion to <code>Float64</code> for the input arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/types.jl#L133-L172">source</a></section></details></article><h2 id="Fitting-methods"><a class="docs-heading-anchor" href="#Fitting-methods">Fitting methods</a><a id="Fitting-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ASSET.extract_spectrum!"><a class="docstring-binding" href="#ASSET.extract_spectrum!"><code>ASSET.extract_spectrum!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_spectrum!(z, F, psf, D, Reg [, Bkg]; kwds...)</code></pre><p>estimates the spectrum of an object observed with long-slit spectroscopy, when the data can be corrupted by a background component and noise. The direct model of such data can be writen: <code>d = Bkg + Diag(H)*F*z + n</code> where <code>*</code> the matrix product. <code>z</code> is the spectrum of the object of interest and <code>F</code> its associated interpolation operator, <code>H</code> the operator modeling the Point Spread Function (PSF) of the instrument, while <code>Bkg</code> is the background component to disentangle from the object of interest and <code>n</code> accounts for noises.</p><p>The data and there associated weights are given by the <code>CalibratedData</code> structure <code>D</code>, while the array <code>H</code> is produced using the method <code>psf_map</code> with the arguments <code>psf</code> and <code>psf_center</code>.</p><p>The estimation of the different unknowns relies on the minimization of the a posteriori likelihood, where <code>Reg</code> is the regularization function of <code>z</code> (of type <code>InverseProblem.Regularization</code>) and where <code>Bkg</code> is a structure of type <code>AbstractBkg</code>, which contains a way to produce the background component and its regularization function. If <code>Bkg</code> is not given, the algorithm will suppose that there is no background in the data and will only call <code>fit_spectrum_and_psf!</code>. If there is a <code>Bkg</code> given, the algorithm will alternate the estimation of the background using <code>fit_bkg!</code> with the extraction of the spectrum (done in <code>fit_spectrum_and_psf!</code>).</p><p>Finally, an auto-calibration step can be activated which will refine the parameters and center of the PSF.</p><p><strong>Keywords</strong></p><ul><li><code>auto_calib</code> : (<code>Val(true)</code> by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum. It can also take the value <code>Val(:delay)</code> which will run the algorithm without auto<em>calib until it converges, before activating the `auto</em>calib` and re-running the algorithm.</li><li><code>mask_width</code> : (<code>3</code> by default) defines the number of fwhm of the psf will be used to hide the object on the first iteration of the background estimtion (if thee is one).</li><li><code>max_iter</code> : (<code>1000</code> by default) defines the maximum number of iterations that can do the method (useful when <code>auto_calib=true</code>).</li><li><code>loss_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.</li><li><code>z_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate <code>z</code> as a stop criterion.</li><li><code>extract_kwds</code> : (<code>(verb=true,)</code> by default) where other keywords can be given which are forwarded to the <code>object_step</code> method. </li></ul><p><strong>See also</strong></p><ul><li><a href="#ASSET.AbstractBkg"><code>AbstractBkg</code></a></li><li>[<code>PointSpreadFunctions.AbstractPSF</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L9-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.fit_spectrum_and_psf!"><a class="docstring-binding" href="#ASSET.fit_spectrum_and_psf!"><code>ASSET.fit_spectrum_and_psf!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_spectrum_and_psf!(z, psf, F, D, Reg; kwds...)</code></pre><p>yields the object spectrum <code>z</code>, the off-axis PSF <code>psf</code>, extracted from the <code>CalibratedData</code> <code>D</code> via an a posteriori likelihood minimization with regularization <code>Reg</code>. The model of the object is defined by <code>Diag(H)*F*z</code> where <code>H</code> is found via the <code>psf</code> arguments, using the method <code>psf_map!</code>. The optimization problem is solved by the <code>vmlmb</code> method defined in the <code>OptimPackNextGen</code> package by calling the method <code>fit_spectrum!</code>.</p><p>An auto-calibration step can be done to better estimate the parameters, in<code>psf</code>, and shift to apply to the center of the PSF. The Bobyqa method of Powell is used to estimate these quantities.</p><p><strong>Keywords</strong></p><ul><li><code>auto_calib</code> : (<code>Val(true)</code> by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum.</li><li><code>psf_shift_bnds</code> : (a vector of zero-values Tuple by default) defines the boundaries of the parameters of the PSF. If <code>auto_calib=true</code>, the user must specify them.</li><li><code>psf_center_bnds</code> : (a zero-valued integer by default) defines the boundaries of the center of the PSF along the spectral axis. If <code>auto_calib=true</code>, the user must specify them.</li><li><code>max_iter</code> : (<code>1000</code> by default) defines the maximum number of iterations that can do the method (useful when <code>auto_calib=true</code>).</li><li><code>max_amors_iter</code> : (<code>10</code> by default) defines the maximum number of iterations that can do the method <code>AMORS</code>.</li><li><code>amors_tol</code> : (<code>(1e-3,1e-3)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the &#39;AMORS&#39; loss function as a stop criterion.</li><li><code>loss_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.</li><li><code>z_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate <code>z</code> as a stop criterion.</li><li><code>h_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative  tolerance between two consecutive iteration of the estimate of the PSF as a stop criterion.</li><li>Other keywords can be given which are forwarded to the Bobyqa nethod.</li></ul><p><strong>Returns</strong></p><ul><li><code>z</code> : the estimated object spectrum.</li><li><code>psf</code> : the estimated off-axis PSF.</li></ul><p><strong>See also</strong></p><ul><li>[<code>OptimPackNextGen.vmlbm</code>]</li><li>[<code>OptimPackNextGen.Powell.Bobyqa</code>]</li><li><a href="#ASSET.psf_map!"><code>psf_map!</code></a></li><li><a href="#ASSET.fit_spectrum!"><code>fit_spectrum!</code></a></li><li>[<code>AMORS</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/non_parametric_fitting.jl#L53-L104">source</a></section><section><div><pre><code class="language-julia hljs">fit_spectrum_and_psf!(z, psf, F, D, Reg; kwds...)</code></pre><p>yields the object spectrum <code>z</code>, the off-axis PSF <code>psf</code>, extracted from the <code>CalibratedData</code> <code>D</code> via an a posteriori likelihood minimization with regularization <code>Reg</code>. The model of the object is defined by <code>Diag(H)*F*z</code> where <code>H</code> is found via the  <code>psf</code> arguments, using the method <code>psf_map!</code>. The optimization problem is solved by the <code>vmlmb</code> method defined in the <code>OptimPackNextGen</code> package by calling the method <code>fit_spectrum!</code>.</p><p>An auto-calibration step can be done to better estimate the parameters of the PSF. The Bobyqa method of Powell is used to estimate these quantities.</p><p><strong>Keywords</strong></p><ul><li><code>auto_calib</code> : (<code>Val(true)</code> by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum.</li><li><code>psf_params_bnds</code> : (a vector of zero-values Tuple by default) defines the boundaries of the parameters of the PSF. If <code>auto_calib=true</code>, the user must specify them.</li><li><code>psf_center_bnds</code> : (a zero-valued integer by default) defines the boundaries of the center of the PSF along the spectral axis. If <code>auto_calib=true</code>, the user must specify them.</li><li><code>max_iter</code> : (<code>1000</code> by default) defines the maximum number of iterations that can do the method (useful when <code>auto_calib=true</code>).</li><li><code>loss_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.</li><li><code>z_tol</code> : (<code>(0,1e-6)</code> by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate <code>z</code> as a stop criterion.</li><li>Other keywords can be given which are forwarded to the Bobyqa nethod.</li></ul><p><strong>See also</strong></p><ul><li>[<code>OptimPackNextGen.vmlbm</code>]</li><li>[<code>OptimPackNextGen.Powell.Bobyqa</code>]</li><li><a href="#ASSET.psf_map!"><code>psf_map!</code></a></li><li><a href="#ASSET.fit_spectrum!"><code>fit_spectrum!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/parametric_fitting.jl#L53-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.fit_spectrum!"><a class="docstring-binding" href="#ASSET.fit_spectrum!"><code>ASSET.fit_spectrum!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_spectrum!(z, F, H, D, Reg ; kwds...)</code></pre><p>check if the <code>Regularization</code> <code>R</code> can be used in a direct inversion framework before calling the solve function (either <code>solve_analytic</code> or <code>solve_vmlmb</code>). The keywords <code>kwds</code> are forwarded to the method that solves the problem.</p><p><strong>See also</strong></p><ul><li>[<code>InverseProblem.Regul</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L172-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.fit_psf_center!"><a class="docstring-binding" href="#ASSET.fit_psf_center!"><code>ASSET.fit_psf_center!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_psf_center(psf_center, psf, z, F, D; kwds...)</code></pre><p>yields the center of the psf along the spectral axis, stored in <code>psf_center</code>, estimated by minimizing the likelihood formed with the <code>CalibratedData</code> <code>D</code>, the spectrum of the object <code>z</code> and the <code>SparseInterpolator</code> <code>F</code>.</p><p>#Keywords</p><ul><li><code>psf_center_bnds</code> : (a vector of zero-values Tuple by default) defines the boundaries of the center of the PSF along the spectral axis. The user must specify them.</li><li><code>rho_tol</code> : (<code>undef</code> by default) defines the size of the trust-region used to estimate the parameters of the PSF.</li><li>Other keywords can be given which are forwarded to the Bobyqa nethod.</li></ul><p><strong>See also</strong></p><ul><li>[<code>OptimPackNextGen.Powell.Bobyqa</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L201-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.fit_psf_params"><a class="docstring-binding" href="#ASSET.fit_psf_params"><code>ASSET.fit_psf_params</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_psf_params(psf, psf_center, z, F, D; kwds...)</code></pre><p>yields a new PSF structure of same type than <code>psf</code>, where its parameters are estimated by Powell&#39;s Bobyqa method as defined in <code>OptimPackNextGen</code>. The center of the PSF is defined by the vector <code>psf_center</code>, while the spectrum of the object of interest can be retireve using the vector <code>z</code>, the <code>SparseInterpolator</code>F<code>, and the</code>CalibratedData<code></code>D`.</p><p><strong>Keywords</strong></p><ul><li><code>psf_params_bnds</code> : (a vector of zero-values Tuple by default) defines the boundaries of the parameters of the PSF. The user must specify them.</li><li><code>rho_tol</code> : (<code>undef</code> by default) defines the size of the trust-region used to estimate the parameters of the PSF.</li><li>Other keywords can be given which are forwarded to the Bobyqa nethod.</li></ul><p><strong>See also</strong></p><ul><li>[<code>OptimPackNextGen.Powell.Bobyqa</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/parametric_fitting.jl#L152-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.fit_psf_shift"><a class="docstring-binding" href="#ASSET.fit_psf_shift"><code>ASSET.fit_psf_shift</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>fit<em>psf</em>shift(psf, z, F, D; psf<em>shift</em>bnds = (0.,0.), kwds...)</p><p>Fits the shift parameter of a non-parametric point spread function (PSF) by minimizing a likelihood function. </p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: The initial non-parametric PSF object.</li><li><code>z</code>: The parameter vector for likelihood evaluation.</li><li><code>F</code>: Sparse interpolator used in the likelihood calculation.</li><li><code>D</code>: Calibrated data containing observed data, weights, and mapping information.</li><li><code>psf_shift_bnds</code>: Optional. Tuple specifying the lower and upper bounds for the PSF shift parameter. Defaults to <code>(0., 0.)</code>.</li><li><code>kwds...</code>: Additional keyword arguments passed to the optimizer.</li></ul><p><strong>Returns</strong></p><ul><li><code>NonParametricPSF</code>: A new PSF object with the optimized shift parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/non_parametric_fitting.jl#L173-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.psf_map!"><a class="docstring-binding" href="#ASSET.psf_map!"><code>ASSET.psf_map!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">psf_map!(map, h, ρ, λ)</code></pre><p>store in the <code>AbstractArray</code> <code>map</code> the result of applying the psf function stored in the <code>NonParametricPSF</code> <code>h</code>, to each pixel <code>i</code> of the spatial and spectral maps <code>ρ</code> and <code>λ</code>.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.psf_map"><code>psf_map</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/non_parametric_fitting.jl#L9-L18">source</a></section><section><div><pre><code class="language-julia hljs">psf_map!(map, h, ρ, λ)</code></pre><p>store in the <code>AbstractArray</code> <code>map</code> the result of applying the psf function stored in the <code>ParametricPSF</code> <code>h</code>, to each pixel <code>i</code> of the spatial and spectral maps <code>ρ</code> and <code>λ</code>.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.psf_map"><code>psf_map</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/parametric_fitting.jl#L9-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.psf_map"><a class="docstring-binding" href="#ASSET.psf_map"><code>ASSET.psf_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>psf_map(h, ρ, λ)</p><p>yield the result of <code>psf_map!</code> and store it in a new <code>AbstractArray</code>.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.psf_map!"><code>psf_map!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/non_parametric_fitting.jl#L30-L37">source</a></section><section><div><pre><code class="language-julia hljs">psf_map(h, ρ, λ)</code></pre><p>yield the result of <code>psf_map!</code> and store it in a new <code>AbstractArray</code>.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.psf_map!"><code>psf_map!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/parametric_fitting.jl#L31-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.loss"><a class="docstring-binding" href="#ASSET.loss"><code>ASSET.loss</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loss(D, H, F, z, Reg [, Bkg=undef])</code></pre><p>yields the value of the loss function used to estimate the different parameters of the problem: <code>(Diag(H)*F*z + Bkg.b - D.d)&#39;*Diag(D.w)*(Diag(H)*F*z + Bkg.b - D.d) + Reg(z) + regul(Bkg)</code> where <code>Bkg.b</code> and <code>regul(Bkg)</code> are not taken into account if <code>Bkg=undef</code>.</p><p><strong>See also</strong></p><ul><li><a href="#ASSET.AbstractBkg"><code>AbstractBkg</code></a></li><li>[<code>InverseProblem.Regul</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L357-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.solve_analytic"><a class="docstring-binding" href="#ASSET.solve_analytic"><code>ASSET.solve_analytic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_analytic!(F, H, D, Reg)</code></pre><p>yields the estimator by directly inverting the Normal equations: <code>(F&#39;*H&#39;*Diag(D.w)*H*F + get_grad_op(R)) * z = F&#39;.H*Diag(D.w)*D.d</code> where <code>D</code> is a <code>CalibratedData</code>, <code>get_grad_op</code> is a method returning the operator of the gradient of the <code>Regularization</code> <code>Reg</code> and <code>z</code> is the estimator the user is looking for.</p><p><strong>See also</strong></p><ul><li>[<code>InversePbm.get_grad_op</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L273-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.solve_vmlmb"><a class="docstring-binding" href="#ASSET.solve_vmlmb"><code>ASSET.solve_vmlmb</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_vmlmb!(z0, A, D, Reg; [nonnegative=false,] kwds...)</code></pre><p>uses the <code>vmlmb!</code> method of <code>OptimPackNextGen</code> to estimate the solution of: <code>argmin (A*z - D.d)&#39;*Diag(D.w)*(A*z - D.d) + Reg(z)                z</code> with <code>D</code> a <code>CalibratedData</code>. The result is stored in <code>z0</code>.</p><p>It is possible to indicate to the method <code>vmlmb</code> a positivity constraint for <code>z</code> by using the <code>nonnegative</code> keyword, as well as indicate more keywords to constrain the optimization.</p><p><strong>See also</strong></p><ul><li>[<code>OptimPackNextGen.vmlbm!</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L312-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ASSET.mask_object"><a class="docstring-binding" href="#ASSET.mask_object"><code>ASSET.mask_object</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mask_object(ρ_map, λ_map, psf [; mask_width=3])</code></pre><p>yields a mask array of same size than <code>ρ_map</code> and <code>λ_map</code>, where all the pixels of distance less than the fwhm of <code>psf</code> times the <code>mask_width</code> are flagged as zeros, while the rest are at unitary level.</p><p>To do so, the user needs to make sure that the <code>ρ_map</code> has its origin centered on the object of interest.</p><p><strong>See also</strong></p><ul><li>[<code>PointSpreadFunctions.AbstractPSF</code>]</li><li>[<code>PointSpreadFunctions.get_fwhm</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SlitSpectroscopyBuddies/ASSET/blob/669f37a8e0988497c38299a8760bae1946db8e08/src/algorithms.jl#L136-L149">source</a></section></details></article><ul><li>link to <a href="#ASSET.AbstractBkg"><code>ASSET.AbstractBkg</code></a></li><li>link to <a href="#ASSET.BkgMdl"><code>ASSET.BkgMdl</code></a></li><li>link to <a href="#ASSET.psf_map!"><code>ASSET.psf_map!</code></a></li><li>link to <a href="#ASSET.psf_map"><code>ASSET.psf_map</code></a></li><li>link to <a href="#ASSET.fit_spectrum!"><code>ASSET.fit_spectrum!</code></a></li><li>link to <a href="#ASSET.ChromaticSeriesExpansionsInterpolator"><code>ASSET.ChromaticSeriesExpansionsInterpolator</code></a></li></ul><ul><li><a href="#ASSET.AbstractBkg"><code>ASSET.AbstractBkg</code></a></li><li><a href="#ASSET.BkgMdl"><code>ASSET.BkgMdl</code></a></li><li><a href="#ASSET.CalibratedData"><code>ASSET.CalibratedData</code></a></li><li><a href="#ASSET.ChromaticSeriesExpansionsInterpolator"><code>ASSET.ChromaticSeriesExpansionsInterpolator</code></a></li><li><a href="#ASSET.NonParametricPSF"><code>ASSET.NonParametricPSF</code></a></li><li><a href="#ASSET.ParametricPSF"><code>ASSET.ParametricPSF</code></a></li><li><a href="#ASSET.SeriesExpansionPSF"><code>ASSET.SeriesExpansionPSF</code></a></li><li><a href="#ASSET.chromGaussianPSF"><code>ASSET.chromGaussianPSF</code></a></li><li><a href="#ASSET.chromMoffatPSF"><code>ASSET.chromMoffatPSF</code></a></li><li><a href="#ASSET.chromwmwGaussianPSF"><code>ASSET.chromwmwGaussianPSF</code></a></li><li><a href="#ASSET.chromwmwMoffatPSF"><code>ASSET.chromwmwMoffatPSF</code></a></li><li><a href="#ASSET.extract_spectrum!"><code>ASSET.extract_spectrum!</code></a></li><li><a href="#ASSET.fit_psf_center!"><code>ASSET.fit_psf_center!</code></a></li><li><a href="#ASSET.fit_psf_params"><code>ASSET.fit_psf_params</code></a></li><li><a href="#ASSET.fit_psf_shift"><code>ASSET.fit_psf_shift</code></a></li><li><a href="#ASSET.fit_spectrum!"><code>ASSET.fit_spectrum!</code></a></li><li><a href="#ASSET.fit_spectrum_and_psf!"><code>ASSET.fit_spectrum_and_psf!</code></a></li><li><a href="#ASSET.loss"><code>ASSET.loss</code></a></li><li><a href="#ASSET.mask_object"><code>ASSET.mask_object</code></a></li><li><a href="#ASSET.psf_map"><code>ASSET.psf_map</code></a></li><li><a href="#ASSET.psf_map!"><code>ASSET.psf_map!</code></a></li><li><a href="#ASSET.solve_analytic"><code>ASSET.solve_analytic</code></a></li><li><a href="#ASSET.solve_vmlmb"><code>ASSET.solve_vmlmb</code></a></li></ul><h1 id="Theoretical-Background"><a class="docs-heading-anchor" href="#Theoretical-Background">Theoretical Background</a><a id="Theoretical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Background" title="Permalink"></a></h1><p>The method used in the <a href="https://github.com/SlitSpectroscopyBuddies/ASSET"><code>ASSET</code></a> package requires the following maps as inputs: </p><ul><li>data maps <span>$(d_\ell)_{\ell \in {1:L}}$</span>, where <span>$L$</span> is the amount of dithers/acquisitions/frames;</li><li>weights maps <span>$w_\ell$</span>, where each element can be computed as the inverse variance of the pixel, forming the matrix <span>$W_{\ell}= \Sigma_{\ell}^{-2}$</span>. We assume that a defective pixel or artifacts have an infinite variance, i.e. a zero entry in <span>$W_{\ell}$</span>;</li><li>spatial coordinate maps <span>$X_\ell$</span> where <span>$0$</span> should correspond to the center of the studied object;</li><li>spectral coordinate maps <span>$\Lambda_\ell$</span>.</li></ul><p>The method outputs are the extracted spectrum <span>$z$</span>, sampled over a given regular wavelength grid <span>$(\lambda_n)_{n \in 1:N}$</span>, and the parameters <span>$\theta$</span> of the fitted PSF model. They are obtained by solving:  </p><p class="math-container">\[
z,\theta \in \mathrm{arg min} \Big\{\sum_\ell\Vert d_\ell - (m_\ell(z,\theta) + b)\Vert_{W_{\ell}}^2 + \mu_z\mathcal{R}_z(z) + \mu_\theta\mathcal{R}_\theta(\theta) + \mu_b\mathcal{R}_b(b), \Big\}
$

where $\mathcal{R}_z\]</p><p>, <span>$\mathcal{R}_\theta$</span> and <span>$\mathcal{R}_b$</span> are respectively the regularization of the extracted spectra, of the PSF parameters if required and of the background, with hyperparameters <span>$\mu_z$</span>, <span>$\mu_\theta$</span> and <span>$\mu_b$</span>. The spatial distribution maps <span>$X$</span> and the background map <span>$b$</span> are auto-calibrated in the process.  The model of the data</p><p class="math-container">\[
m_\ell(z,\theta) = \alpha_\ell Z(\Lambda_\ell,z) \odot H(\theta, X_\ell, \Lambda_\ell)\]</p><p>is the Hadamard (element-wise) product of the spectrum interpolated in the camera plane</p><p class="math-container">\[
Z(\Lambda,z)_{j,k}=\sum_n\phi\Big(\frac{\Lambda_{j,k}-\lambda_n}{\delta_\lambda}\Big)z_n
$

with $\phi\]</p><p>an interpolation kernel, and of the chromatic PSF <span>$H$</span> (parametric or non-parametric). The package provide several <code>ParametricPSF</code> and <code>NonParametricPSF</code> and the users can easily implement their own. A <code>ParametricPSF</code>  <span>$H$</span> is a function parametrized by a few unknown variables <span>$\theta_m$</span>, thus with low degrees of freedom, <em>e.g.</em> a Gaussian chromatic with a minimum width model:</p><p class="math-container">\[
H(\theta, X_\ell, \Lambda_\ell)_{j,k} = \big(2 \pi(\theta_1 \Lambda_{j,k\ell}^2 + \theta_2)\big)^{-1}\exp\Big(-\frac{X_{j,k,\ell}^2}{2(\theta_1\Lambda_{j,k,\ell}^2+\theta_2)}\Big).
$

It does not require any regularization. See @The:2023 and @Denneulin:2023 for more details. 

A `NonParametricPSF` is parametrized directly by some profile $(\theta_m)_{m \in  1:M}\]</p><p>, thus with high degrees of freedom , <em>e.g.</em> taking <span>$o$</span> order of the speckles expansion model [@Devaney:2017] which is the interpolation of the profiles <span>$\theta_o$</span> in a reference plane of the spatial coordinates <span>$(x_m)_{m \in 1:M}$</span>,:</p><p class="math-container">\[
H(\theta, X_\ell, \Lambda_\ell)_{j,k} = \sum_o \gamma(\Lambda_\ell)^o \sum_m \phi\Big(\frac{\gamma(\Lambda_\ell)X_\ell - x_m}{\delta x}\Big)\theta_{m,o}(x_m).
$

For such a PSF, $\theta\]</p><p>must be regularized. The hyperparameter is auto-calibrated in the method (see @The:2023 for and references therein for more details). </p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 15:11">Friday 27 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
