var documenterSearchIndex = {"docs":
[{"location":"#ASSET-Documentation","page":"ASSET Documentation","title":"ASSET Documentation","text":"","category":"section"},{"location":"#Types","page":"ASSET Documentation","title":"Types","text":"","category":"section"},{"location":"#PSF-models","page":"ASSET Documentation","title":"PSF models","text":"","category":"section"},{"location":"#Fitting-methods","page":"ASSET Documentation","title":"Fitting methods","text":"link to ASSET.AbstractBkg\nlink to ASSET.BkgMdl\nlink to ASSET.psf_map!\nlink to ASSET.psf_map\nlink to ASSET.fit_spectrum!\nlink to ASSET.ChromaticSeriesExpansionsInterpolator\n\n","category":"section"},{"location":"#Theoretical-Background","page":"ASSET Documentation","title":"Theoretical Background","text":"The method used in the ASSET package requires the following maps as inputs: \n\ndata maps (d_ell)_ell in 1L, where L is the amount of dithers/acquisitions/frames;\nweights maps w_ell, where each element can be computed as the inverse variance of the pixel, forming the matrix W_ell= Sigma_ell^-2. We assume that a defective pixel or artifacts have an infinite variance, i.e. a zero entry in W_ell;\nspatial coordinate maps X_ell where 0 should correspond to the center of the studied object;\nspectral coordinate maps Lambda_ell.\n\nThe method outputs are the extracted spectrum z, sampled over a given regular wavelength grid (lambda_n)_n in 1N, and the parameters theta of the fitted PSF model. They are obtained by solving:  \n\n\nztheta in mathrmarg min Bigsum_ellVert d_ell - (m_ell(ztheta) + b)Vert_W_ell^2 + mu_zmathcalR_z(z) + mu_thetamathcalR_theta(theta) + mu_bmathcalR_b(b) Big\n\n\nwhere mathcalR_z\n\n, mathcalR_theta and mathcalR_b are respectively the regularization of the extracted spectra, of the PSF parameters if required and of the background, with hyperparameters mu_z, mu_theta and mu_b. The spatial distribution maps X and the background map b are auto-calibrated in the process.  The model of the data\n\n\nm_ell(ztheta) = alpha_ell Z(Lambda_ellz) odot H(theta X_ell Lambda_ell)\n\nis the Hadamard (element-wise) product of the spectrum interpolated in the camera plane\n\n\nZ(Lambdaz)_jk=sum_nphiBig(fracLambda_jk-lambda_ndelta_lambdaBig)z_n\n\n\nwith phi\n\nan interpolation kernel, and of the chromatic PSF H (parametric or non-parametric). The package provide several ParametricPSF and NonParametricPSF and the users can easily implement their own. A ParametricPSF  H is a function parametrized by a few unknown variables theta_m, thus with low degrees of freedom, e.g. a Gaussian chromatic with a minimum width model:\n\n\nH(theta X_ell Lambda_ell)_jk = big(2 pi(theta_1 Lambda_jkell^2 + theta_2)big)^-1expBig(-fracX_jkell^22(theta_1Lambda_jkell^2+theta_2)Big)\n\n\nIt does not require any regularization See The2023 and Denneulin2023 for more details \n\nA NonParametricPSF is parametrized directly by some profile (theta_m)_m in  1M\n\n, thus with high degrees of freedom , e.g. taking o order of the speckles expansion model [@Devaney:2017] which is the interpolation of the profiles theta_o in a reference plane of the spatial coordinates (x_m)_m in 1M,:\n\n\nH(theta X_ell Lambda_ell)_jk = sum_o gamma(Lambda_ell)^o sum_m phiBig(fracgamma(Lambda_ell)X_ell - x_mdelta xBig)theta_mo(x_m)\n\n\nFor such a PSF theta\n\nmust be regularized. The hyperparameter is auto-calibrated in the method (see @The:2023 for and references therein for more details). ","category":"section"},{"location":"#ASSET.AbstractBkg","page":"ASSET Documentation","title":"ASSET.AbstractBkg","text":"AbstractBkg\n\nType that defines a background structure, that is used to specify a certain model of the background present in the data and its associated regularization. This structure is used when one want to both estimate the background sources of the data and extracting the spectrum of the object of interest.\n\nTo define a structure B of type AbstractBkg, the user needs to overload three methods:\n\njulia> get_bkg(B)\n\nwhich yields the background as an AbstractArray from parameters contained in B.\n\njulia> regul(B)\n\nwhich yields the result of the regularization term(s), applied to the curent background model, that are used in the a posteriori likelihood minimization.\n\njulia> fit_bkg!(B, D)\n\nwhere D is a CalibratedData. This last function is the one called by extract_spectrum to estimate the background when assuming the object spectrum known (alternate estimation). \n\nSee also\n\nBkgMdl\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.ParametricPSF","page":"ASSET Documentation","title":"ASSET.ParametricPSF","text":"ParametricPSF{N} <: AbstractPSF{N}\n\nAn abstract type representing a parametric point spread function (PSF) with N arguments. Subtypes P should implement specific parametric models for PSFs as well as parameters(::P) yielding its parameters, getfwhm(::P) its fwhm and ::P(::Int, ::Int) its value at a given position on the detector. Inherits from AbstractPSF{N}.\n\nSee Also\n\n[AbstractPSF]\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.NonParametricPSF","page":"ASSET Documentation","title":"ASSET.NonParametricPSF","text":"NonParametricPSF{N} <: AbstractPSF{N}\n\nAn abstract type representing a non-parametric point spread function (PSF) with N arguments. Subtypes of NonParametricPSF are expected to define PSFs that are not described by a fixed set of parameters, but rather by data-driven or empirical representations. Subtypes P should implement specific parametric models for PSFs as well as parameters(::P) yielding its parameters, getfwhm(::P) its fwhm and ::P(::Int, ::Int) its value at a given position on the detector.This type is a subtype of AbstractPSF{N}.\n\nSee Also\n\n[AbstractPSF]\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.BkgMdl","page":"ASSET Documentation","title":"ASSET.BkgMdl","text":"BkgMdl(b, R)\n\nyields a structure of type AbstractBkg, composed of an AbstractArray b and an associated regularization R of type Regularization.\n\nExample\n\n# create a BkgMdl structure\njulia> B = BkgMdl(b, R)\n# add the structure to an AbstractArray\njulia> A = ones(size(b))\njulia> A + B\n\nTo apply the regularization to the background array:\n\njulia> regul(B)\n\nTo fit the background to some CalibratedData D:\n\njulia> fit_bkg!(B, D, true, kwds...)\n\nwhere kwds specifies all the keywords used by the optimization method to estimate the background.\n\nSee also\n\nAbstractBkg\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.CalibratedData","page":"ASSET Documentation","title":"ASSET.CalibratedData","text":"struct CalibratedData{T<:AbstractFloat, N, D<:AbstractArray{T,N}}\n\nA container for storing calibrated scientific data and associated weights  w, the angular separation ρ_map and wavelength λ_map maps calibrating the detector.\n\nArguments\n\nd::D: The main scientific data array.\nw::D: The weight array corresponding to the data.\nρ_map::D: The spatial map associated with the data.\nλ_map::D: The spectral map associated with the data.\n\nThe Base methods axes, size, eltype and show have been overload to be used with such a structure.\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.chromGaussianPSF","page":"ASSET Documentation","title":"ASSET.chromGaussianPSF","text":"chromGaussianPSF(a) -> h\n\nYields an AbstractPSF h, more precisely a gaussian chromatic  PSF parametrized by a, such that the gaussian variance is  σ² = aλ².\n\nThen: \n\nh(ρ,λ)\n\ngives the value of the gaussian chromatic PSF for:\n\nρ, a float giving the position in the slit (in pixels)\nλ, a float giving the wavelength (in μm)\n\nwhich is:\n\n    exp(-1/2 ρ²/σ²)/sqrt(2πσ²)\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.chromwmwGaussianPSF","page":"ASSET Documentation","title":"ASSET.chromwmwGaussianPSF","text":"chromwmwGaussianPSF(p) -> h\n\nYields an AbstractPSF h, more precisely a gaussian chromatic  PSF parametrized by two variables given in a vector p = [a,b]:\n\na the chromatic scalling\nb the minimum width\n\nsuch that the the variance of the PSF is  σ² = aλ² + b\n\nThen: \n\nh(ρ,λ)\n\ngives the value of the gaussian chromatic PSF for:\n\nρ, a float giving the position in the slit (in pixels)\nλ, a float giving the wavelength (in μm)\n\nwhich is:\n\n    exp(-1/2 ρ²/σ²)/sqrt(2πσ²)\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.chromMoffatPSF","page":"ASSET Documentation","title":"ASSET.chromMoffatPSF","text":"chromMoffatPSF(p) -> h\n\nYields an AbstractPSF h, more precisely a centrosymetric Moffat chromatic  PSF parametrized by two variables given in a vector p=[a, β]:\n\n`a the chromatic scalling\nβ the Moffat parameter\n\nsuch that the the variance of the PSF is  σ² = aλ²\n\nThen: \n\nh(ρ,λ)\n\ngives the value of the centrosymetric Moffat chromatic PSF for:\n\nρ, a float giving the position in the slit (in pixels)\nλ, a float giving the wavelength (in μm)\n\nwhich is:\n\n    (1 + ρ²/σ²)^(-β)\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.chromwmwMoffatPSF","page":"ASSET Documentation","title":"ASSET.chromwmwMoffatPSF","text":"chromwmwMoffatPSF(p) -> h\n\nYields an AbstractPSF h, more precisely a centrosymetric Moffat chromatic  PSF parametrized by two variables given in a vector p=[a, b, β]:\n\na the chromatic scalling\nb the minimum width\nβ the Moffat parameter\n\nsuch that the the variance of the PSF is  σ² = aλ² + b\n\nThen: \n\nh(ρ,λ)\n\ngives the value of the centrosymetric Moffat chromatic PSF for:\n\nρ, a float giving the position in the slit (in pixels)\nλ, a float giving the wavelength (in μm)\n\nwhich is:\n\n    (1 + ρ²/σ²)^(-β)\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.SeriesExpansionPSF","page":"ASSET Documentation","title":"ASSET.SeriesExpansionPSF","text":"SeriesExpansionPSF(x) -> h\n\nYields an AbstractPSF h, more precisely a non-parametric PSF using a series expansion approach, parametrized by:\n\nh: a matrix containing the series expansion coefficients\nx: a range containing the wavelengths at which the series expansion coefficients are defined\na: a float giving the chromatic scaling (default is 0, i.e., no scaling)\nker: an interpolation kernel (default is CatmullRomSpline with Flat boundary conditions)\nR: a regularization (default is Tikhonov regularization)\n\nThen: \n\nh(ρ,λ)\n\ngives the value of the chromatic series expansion PSF for:\n\nρ, a float giving the position in the slit (in pixels)\nλ, a float giving the wavelength (in μm)\n\nwhich is given by the ChromaticSeriesExpansionsInterpolator structure.\n\nSee also\n\nChromaticSeriesExpansionsInterpolator\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.ChromaticSeriesExpansionsInterpolator","page":"ASSET Documentation","title":"ASSET.ChromaticSeriesExpansionsInterpolator","text":"struct ChromaticSeriesExpansionsInterpolator <: LinearMapping\n\nA structure representing a chromatic series expansions interpolator, which performs linear mapping operations for chromatic data interpolation. \n\nArguments\n\ncols: Tuple specifying the number of columns (output dimensions). \nrows: Tuple specifying the number of rows (input dimensions).\nker: Kernel object used for interpolation.\nX: Array of input positions.\nΛ: Array of wavelength or chromatic values.\nx: Range of positions for interpolation.\nλref: Reference wavelength for normalization.\na: Parameter for scaling or regularization.\n\n\n\nChromaticSeriesExpansionsInterpolator{T}(ker::Kernel, X::AbstractArray{T,N}, Λ::AbstractArray{T,N}, x::AbstractRange; order=1, λref=maximum(Λ), a=0.)\n\nConstructs a ChromaticSeriesExpansionsInterpolator with specified kernel, input arrays, and interpolation range. Optionally specify the interpolation order, reference wavelength, and scaling parameter. \n\nArguments\n\nker: Interpolation kernel.\nX: Input position array.\nΛ: Input wavelength/chromatic array.\nx: Range of positions for interpolation.\norder: Interpolation order (default: 1).\nλref: Reference wavelength (default: maximum of Λ).\na: Scaling parameter (default: 0).\n\n\n\nChromaticSeriesExpansionsInterpolator(ker::Kernel, X::AbstractArray{<:Any,N}, Λ::AbstractArray{<:Any,N}, x::AbstractRange; order=1, λref=maximum(Λ), a=0.)\n\nConstructs a ChromaticSeriesExpansionsInterpolator with type promotion to Float64 for the input arrays.\n\n\n\n\n\n","category":"type"},{"location":"#ASSET.extract_spectrum!","page":"ASSET Documentation","title":"ASSET.extract_spectrum!","text":"extract_spectrum!(z, F, psf, D, Reg [, Bkg]; kwds...)\n\nestimates the spectrum of an object observed with long-slit spectroscopy, when the data can be corrupted by a background component and noise. The direct model of such data can be writen: d = Bkg + Diag(H)*F*z + n where * the matrix product. z is the spectrum of the object of interest and F its associated interpolation operator, H the operator modeling the Point Spread Function (PSF) of the instrument, while Bkg is the background component to disentangle from the object of interest and n accounts for noises.\n\nThe data and there associated weights are given by the CalibratedData structure D, while the array H is produced using the method psf_map with the arguments psf and psf_center.\n\nThe estimation of the different unknowns relies on the minimization of the a posteriori likelihood, where Reg is the regularization function of z (of type InverseProblem.Regularization) and where Bkg is a structure of type AbstractBkg, which contains a way to produce the background component and its regularization function. If Bkg is not given, the algorithm will suppose that there is no background in the data and will only call fit_spectrum_and_psf!. If there is a Bkg given, the algorithm will alternate the estimation of the background using fit_bkg! with the extraction of the spectrum (done in fit_spectrum_and_psf!).\n\nFinally, an auto-calibration step can be activated which will refine the parameters and center of the PSF.\n\nKeywords\n\nauto_calib : (Val(true) by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum. It can also take the value Val(:delay) which will run the algorithm without autocalib until it converges, before activating the `autocalib` and re-running the algorithm.\nmask_width : (3 by default) defines the number of fwhm of the psf will be used to hide the object on the first iteration of the background estimtion (if thee is one).\nmax_iter : (1000 by default) defines the maximum number of iterations that can do the method (useful when auto_calib=true).\nloss_tol : ((0,1e-6) by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.\nz_tol : ((0,1e-6) by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate z as a stop criterion.\nextract_kwds : ((verb=true,) by default) where other keywords can be given which are forwarded to the object_step method. \n\nSee also\n\nAbstractBkg\n[PointSpreadFunctions.AbstractPSF]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.fit_spectrum_and_psf!","page":"ASSET Documentation","title":"ASSET.fit_spectrum_and_psf!","text":"fit_spectrum_and_psf!(z, psf, F, D, Reg; kwds...)\n\nyields the object spectrum z, the off-axis PSF psf, extracted from the CalibratedData D via an a posteriori likelihood minimization with regularization Reg. The model of the object is defined by Diag(H)*F*z where H is found via the psf arguments, using the method psf_map!. The optimization problem is solved by the vmlmb method defined in the OptimPackNextGen package by calling the method fit_spectrum!.\n\nAn auto-calibration step can be done to better estimate the parameters, inpsf, and shift to apply to the center of the PSF. The Bobyqa method of Powell is used to estimate these quantities.\n\nKeywords\n\nauto_calib : (Val(true) by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum.\npsf_shift_bnds : (a vector of zero-values Tuple by default) defines the boundaries of the parameters of the PSF. If auto_calib=true, the user must specify them.\npsf_center_bnds : (a zero-valued integer by default) defines the boundaries of the center of the PSF along the spectral axis. If auto_calib=true, the user must specify them.\nmax_iter : (1000 by default) defines the maximum number of iterations that can do the method (useful when auto_calib=true).\nmax_amors_iter : (10 by default) defines the maximum number of iterations that can do the method AMORS.\namors_tol : ((1e-3,1e-3) by default) defines the absolute and relative tolerance between two consecutive iteration of the 'AMORS' loss function as a stop criterion.\nloss_tol : ((0,1e-6) by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.\nz_tol : ((0,1e-6) by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate z as a stop criterion.\nh_tol : ((0,1e-6) by default) defines the absolute and relative  tolerance between two consecutive iteration of the estimate of the PSF as a stop criterion.\nOther keywords can be given which are forwarded to the Bobyqa nethod.\n\nReturns\n\nz : the estimated object spectrum.\npsf : the estimated off-axis PSF.\n\nSee also\n\n[OptimPackNextGen.vmlbm]\n[OptimPackNextGen.Powell.Bobyqa]\npsf_map!\nfit_spectrum!\n[AMORS]\n\n\n\n\n\nfit_spectrum_and_psf!(z, psf, F, D, Reg; kwds...)\n\nyields the object spectrum z, the off-axis PSF psf, extracted from the CalibratedData D via an a posteriori likelihood minimization with regularization Reg. The model of the object is defined by Diag(H)*F*z where H is found via the  psf arguments, using the method psf_map!. The optimization problem is solved by the vmlmb method defined in the OptimPackNextGen package by calling the method fit_spectrum!.\n\nAn auto-calibration step can be done to better estimate the parameters of the PSF. The Bobyqa method of Powell is used to estimate these quantities.\n\nKeywords\n\nauto_calib : (Val(true) by default) precise if an auto-calibration step of the PSF must be done after extracting the spectrum.\npsf_params_bnds : (a vector of zero-values Tuple by default) defines the boundaries of the parameters of the PSF. If auto_calib=true, the user must specify them.\npsf_center_bnds : (a zero-valued integer by default) defines the boundaries of the center of the PSF along the spectral axis. If auto_calib=true, the user must specify them.\nmax_iter : (1000 by default) defines the maximum number of iterations that can do the method (useful when auto_calib=true).\nloss_tol : ((0,1e-6) by default) defines the absolute and relative tolerance between two consecutive iteration of the loss function as a stop criterion.\nz_tol : ((0,1e-6) by default) defines the absolute and relative tolerance between two consecutive iteration of the estimate z as a stop criterion.\nOther keywords can be given which are forwarded to the Bobyqa nethod.\n\nSee also\n\n[OptimPackNextGen.vmlbm]\n[OptimPackNextGen.Powell.Bobyqa]\npsf_map!\nfit_spectrum!\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.fit_spectrum!","page":"ASSET Documentation","title":"ASSET.fit_spectrum!","text":"fit_spectrum!(z, F, H, D, Reg ; kwds...)\n\ncheck if the Regularization R can be used in a direct inversion framework before calling the solve function (either solve_analytic or solve_vmlmb). The keywords kwds are forwarded to the method that solves the problem.\n\nSee also\n\n[InverseProblem.Regul]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.fit_psf_center!","page":"ASSET Documentation","title":"ASSET.fit_psf_center!","text":"fit_psf_center(psf_center, psf, z, F, D; kwds...)\n\nyields the center of the psf along the spectral axis, stored in psf_center, estimated by minimizing the likelihood formed with the CalibratedData D, the spectrum of the object z and the SparseInterpolator F.\n\n#Keywords\n\npsf_center_bnds : (a vector of zero-values Tuple by default) defines the boundaries of the center of the PSF along the spectral axis. The user must specify them.\nrho_tol : (undef by default) defines the size of the trust-region used to estimate the parameters of the PSF.\nOther keywords can be given which are forwarded to the Bobyqa nethod.\n\nSee also\n\n[OptimPackNextGen.Powell.Bobyqa]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.fit_psf_params","page":"ASSET Documentation","title":"ASSET.fit_psf_params","text":"fit_psf_params(psf, psf_center, z, F, D; kwds...)\n\nyields a new PSF structure of same type than psf, where its parameters are estimated by Powell's Bobyqa method as defined in OptimPackNextGen. The center of the PSF is defined by the vector psf_center, while the spectrum of the object of interest can be retireve using the vector z, the SparseInterpolatorF, and theCalibratedDataD`.\n\nKeywords\n\npsf_params_bnds : (a vector of zero-values Tuple by default) defines the boundaries of the parameters of the PSF. The user must specify them.\nrho_tol : (undef by default) defines the size of the trust-region used to estimate the parameters of the PSF.\nOther keywords can be given which are forwarded to the Bobyqa nethod.\n\nSee also\n\n[OptimPackNextGen.Powell.Bobyqa]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.fit_psf_shift","page":"ASSET Documentation","title":"ASSET.fit_psf_shift","text":"fitpsfshift(psf, z, F, D; psfshiftbnds = (0.,0.), kwds...)\n\nFits the shift parameter of a non-parametric point spread function (PSF) by minimizing a likelihood function. \n\nArguments\n\npsf: The initial non-parametric PSF object.\nz: The parameter vector for likelihood evaluation.\nF: Sparse interpolator used in the likelihood calculation.\nD: Calibrated data containing observed data, weights, and mapping information.\npsf_shift_bnds: Optional. Tuple specifying the lower and upper bounds for the PSF shift parameter. Defaults to (0., 0.).\nkwds...: Additional keyword arguments passed to the optimizer.\n\nReturns\n\nNonParametricPSF: A new PSF object with the optimized shift parameter.\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.psf_map!","page":"ASSET Documentation","title":"ASSET.psf_map!","text":"psf_map!(map, h, ρ, λ)\n\nstore in the AbstractArray map the result of applying the psf function stored in the NonParametricPSF h, to each pixel i of the spatial and spectral maps ρ and λ.\n\nSee also\n\npsf_map\n\n\n\n\n\npsf_map!(map, h, ρ, λ)\n\nstore in the AbstractArray map the result of applying the psf function stored in the ParametricPSF h, to each pixel i of the spatial and spectral maps ρ and λ.\n\nSee also\n\npsf_map\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.psf_map","page":"ASSET Documentation","title":"ASSET.psf_map","text":"psf_map(h, ρ, λ)\n\nyield the result of psf_map! and store it in a new AbstractArray.\n\nSee also\n\npsf_map!\n\n\n\n\n\npsf_map(h, ρ, λ)\n\nyield the result of psf_map! and store it in a new AbstractArray.\n\nSee also\n\npsf_map!\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.loss","page":"ASSET Documentation","title":"ASSET.loss","text":"loss(D, H, F, z, Reg [, Bkg=undef])\n\nyields the value of the loss function used to estimate the different parameters of the problem: (Diag(H)*F*z + Bkg.b - D.d)'*Diag(D.w)*(Diag(H)*F*z + Bkg.b - D.d) + Reg(z) + regul(Bkg) where Bkg.b and regul(Bkg) are not taken into account if Bkg=undef.\n\nSee also\n\nAbstractBkg\n[InverseProblem.Regul]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.solve_analytic","page":"ASSET Documentation","title":"ASSET.solve_analytic","text":"solve_analytic!(F, H, D, Reg)\n\nyields the estimator by directly inverting the Normal equations: (F'*H'*Diag(D.w)*H*F + get_grad_op(R)) * z = F'.H*Diag(D.w)*D.d where D is a CalibratedData, get_grad_op is a method returning the operator of the gradient of the Regularization Reg and z is the estimator the user is looking for.\n\nSee also\n\n[InversePbm.get_grad_op]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.solve_vmlmb","page":"ASSET Documentation","title":"ASSET.solve_vmlmb","text":"solve_vmlmb!(z0, A, D, Reg; [nonnegative=false,] kwds...)\n\nuses the vmlmb! method of OptimPackNextGen to estimate the solution of: argmin (A*z - D.d)'*Diag(D.w)*(A*z - D.d) + Reg(z)                z with D a CalibratedData. The result is stored in z0.\n\nIt is possible to indicate to the method vmlmb a positivity constraint for z by using the nonnegative keyword, as well as indicate more keywords to constrain the optimization.\n\nSee also\n\n[OptimPackNextGen.vmlbm!]\n\n\n\n\n\n","category":"function"},{"location":"#ASSET.mask_object","page":"ASSET Documentation","title":"ASSET.mask_object","text":"mask_object(ρ_map, λ_map, psf [; mask_width=3])\n\nyields a mask array of same size than ρ_map and λ_map, where all the pixels of distance less than the fwhm of psf times the mask_width are flagged as zeros, while the rest are at unitary level.\n\nTo do so, the user needs to make sure that the ρ_map has its origin centered on the object of interest.\n\nSee also\n\n[PointSpreadFunctions.AbstractPSF]\n[PointSpreadFunctions.get_fwhm]\n\n\n\n\n\n","category":"function"}]
}
